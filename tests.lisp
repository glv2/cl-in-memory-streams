;;;; This file is part of in-memory-streams
;;;; Copyright 2022 Guillaume LE VAILLANT
;;;; Distributed under the GNU GPL v3 or later.
;;;; See the file LICENSE for terms of use and distribution.

(defpackage :in-memory-streams/tests
  (:use :cl :fiveam :in-memory-streams))

(in-package :in-memory-streams/tests)


(def-suite in-memory-streams
  :description "Unit tests for in-memory streams")


(def-suite input-streams
  :description "Unit tests for input streams"
  :in in-memory-streams)

(in-suite input-streams)

(test make-input-stream
  (is-true (typep (make-input-stream #()) 'stream))
  (is-true (typep (make-input-stream #(0 1 2 3)) 'stream))
  (is-true (typep (make-input-stream #(0 1 2 3 4 5 6 7 8 9) :start 3) 'stream))
  (is-true (typep (make-input-stream #(0 1 2 3 4 5 6 7 8 9) :start 3 :end 5)
                  'stream))
  (is-true (typep (make-input-stream #(0 1 2 3 4 5 6 7 8 9)
                                     :start 3 :end 5 :element-type 'fixnum)
                  'stream))
  (with-input-stream (s #())
    (is-true (typep s 'stream)))
  (with-input-stream (s #(0 1 2 3))
    (is-true (typep s 'stream)))
  (with-input-stream (s '(0 1 2 3 4 5 6 7 8 9) :start 3)
    (is-true (typep s 'stream)))
  (with-input-stream (s #(0 1 2 3 4 5 6 7 8 9) :start 3 :end 5)
    (is-true (typep s 'stream))
    (is (eql t (stream-element-type s))))
  (with-input-stream (s '(0 1 2 3 4 5 6 7 8 9)
                        :start 3 :end 5 :element-type 'fixnum)
    (is-true (typep s 'stream))
    (is (eql 'fixnum (stream-element-type s))))
  (with-input-stream (s #(0.0 -1.1 2.2 -3.3 4.4 -5.5)
                        :element-type 'single-float)
    (is-true (typep s 'stream))
    (is (eql 'single-float (stream-element-type s)))))

(test listen
  (with-input-stream (s #(1 2 3))
    (is-true (listen s))
    (read-element s)
    (is-true (listen s))
    (read-element s)
    (is-true (listen s))
    (read-element s)
    (is-false (listen s))))

(test read-element
  (with-input-stream (s #(#c(-0.1d0 0.5d0) #c(0.0d0 -1.0d0) #c(1.0d0 0.0d0))
                        :element-type '(complex double-float))
    (is (= 3 (stream-length s)))
    (is (= #c(-0.1d0 0.5d0) (read-element s)))
    (is (= 2 (stream-length s)))
    (is (= #c(0.0d0 -1.0d0) (read-element s)))
    (is (= 1 (stream-length s)))
    (is (= #c(1.0d0 0.0d0) (read-element s)))
    (is (= 0 (stream-length s)))
    (signals end-of-file (read-element s))
    (is (eql :eof (read-element s nil :eof))))
  (with-input-stream (s #(0 1 2 3 4 5 6 7 8 9) :start 3 :end 8)
    (is (= 3 (read-element s)))
    (is (= 4 (read-element s)))
    (is (= 5 (read-element s)))
    (is (= 6 (read-element s)))
    (is (= 7 (read-element s)))
    (is (eql :eof (read-element s nil :eof)))
    (signals end-of-file (read-element s)))
  (with-input-stream (s #(t 5 nil "abc" #(3.14 1.41)))
    (is-true (read-element s))
    (is (= 5 (read-element s)))
    (is-false (read-element s))
    (is (string= "abc" (read-element s)))
    (is (equalp #(3.14 1.41) (read-element s)))
    (is (eql :eof (read-element s nil :eof)))
    (signals end-of-file (read-element s))))

(test read-sequence
  (with-input-stream (s #(0 1 2 3 4 5 6 7 8 9) :element-type 'fixnum)
    (let ((seq (make-array 5 :element-type 'fixnum)))
      (is (= 2 (read-sequence seq s :end 2)))
      (is (equalp #(0 1) (subseq seq 0 2)))
      (is (= 4 (read-sequence seq s :start 2 :end 4)))
      (is (equalp #(0 1 2 3) (subseq seq 0 4)))
      (is (= 5 (read-sequence seq s)))
      (is (equalp #(4 5 6 7 8) seq))
      (is (= 1 (read-sequence seq s)))
      (is (equalp #(9) (subseq seq 0 1)))
      (is (zerop (read-sequence seq s)))))
  (with-input-stream (s #(t 5 nil "abc" #(3.14 1.41)))
    (let ((seq (make-array 5)))
      (is (= 5 (read-sequence seq s)))
      (is (equalp #(t 5 nil "abc" #(3.14 1.41)) seq)))))

(test clear-input
  (with-input-stream (s #(0 1 2 3 4 5 6 7 8 9))
    (is (= 0 (read-element s)))
    (is (= 1 (read-element s)))
    (is (= 2 (read-element s)))
    (clear-input s)
    (signals end-of-file (read-element s))))


(def-suite output-streams
  :description "Unit tests for output streams"
  :in in-memory-streams)

(in-suite output-streams)

(test make-output-stream
  (is-true (typep (make-output-stream) 'stream))
  (is-true (typep (make-output-stream :element-type 'string) 'stream))
  (with-output-stream (s)
    (is-true (typep s 'stream))
    (is (eql t (stream-element-type s))))
  (with-output-stream (s :element-type '(unsigned-byte 8))
    (is-true (typep s 'stream))
    (is (equalp '(unsigned-byte 8) (stream-element-type s)))))

(test write-element
  (let ((seq (with-output-stream (s)
               (is (= 1 (write-element 1 s)))
               (is (eql nil (write-element nil s)))
               (is (string= "abc" (write-element "abc" s)))
               (is (equalp '(1 2 3) (write-element '(1 2 3) s)))
               (is (= #c(-0.12d0 0.3d0) (write-element #c(-0.12d0 0.3d0) s))))))
    (is (= 5 (length seq)))
    (is (equalp #(1 nil "abc" (1 2 3) #c(-0.12d0 0.3d0)) seq)))
  (let ((seq (with-output-stream (s :element-type 'string)
               (is (= 0 (stream-length s)))
               (is (string= "abc" (write-element "abc" s)))
               (is (= 1 (stream-length s)))
               (is (string= "123" (write-element "123" s)))
               (is (= 2 (stream-length s)))
               (is (string= "XYZ" (write-element "XYZ" s)))
               (is (= 3 (stream-length s))))))
    (is (= 3 (length seq)))
    (is (equalp #("abc" "123" "XYZ") seq))))

(test write-sequence
  (with-output-stream (s :element-type 'fixnum)
    (let ((seq (make-array 500 :element-type 'fixnum)))
      (dotimes (i 500)
        (setf (aref seq i) (- (mod (expt i 5) 1000) 500)))
      (is (eq seq (write-sequence seq s :end 5)))
      (is (eq seq (write-sequence seq s :start 5 :end 10)))
      (is (equalp #(-500 -499 -468 -257 -476 -375 276 307 268 -451)
                  (get-elements s)))
      (is (eq seq (write-sequence seq s)))
      (is (equalp seq (get-elements s)))
      (is (eq seq (write-sequence seq s :start 490)))
      (is (equalp #(-500 -49 -268 193 -276 -125 476 -243 468 -1)
                  (get-elements s))))))

(test clear-output
  (let ((seq (with-output-stream (s)
               (is (eql t (write-element t s)))
               (is (eql nil (write-element nil s)))
               (is (eql nil (write-element nil s)))
               (is (eql t (write-element t s)))
               (is (eql t (write-element t s)))
               (clear-output s))))
    (is (= 0 (length seq)))))


(def-suite io-streams
  :description "Unit tests for io streams"
  :in in-memory-streams)

(in-suite io-streams)

(test make-io-stream
  (is-true (typep (make-io-stream) 'stream))
  (is-true (typep (make-io-stream :element-type 'string) 'stream))
  (with-io-stream (s)
    (is-true (typep s 'stream))
    (is (eql t (stream-element-type s))))
  (with-io-stream (s :element-type '(unsigned-byte 8))
    (is-true (typep s 'stream))
    (is (equalp '(unsigned-byte 8) (stream-element-type s)))))

(test listen/io
  (with-io-stream (s)
    (is-false (listen s))
    (write-sequence #(1 2 3) s)
    (is-true (listen s))
    (read-element s)
    (is-true (listen s))
    (read-element s)
    (is-true (listen s))
    (read-element s)
    (is-false (listen s))))

(test read-element/io
  (with-io-stream (s :element-type '(complex double-float))
    (write-sequence #(#c(-0.1d0 0.5d0) #c(0.0d0 -1.0d0) #c(1.0d0 0.0d0)) s)
    (is (= 3 (stream-length s)))
    (is (= #c(-0.1d0 0.5d0) (read-element s)))
    (is (= 2 (stream-length s)))
    (is (= #c(0.0d0 -1.0d0) (read-element s)))
    (is (= 1 (stream-length s)))
    (is (= #c(1.0d0 0.0d0) (read-element s)))
    (is (= 0 (stream-length s)))
    (signals end-of-file (read-element s))
    (is (eql :eof (read-element s nil :eof))))
  (with-io-stream (s)
    (write-sequence #(0 1 2 3 4 5 6 7 8 9) s :start 3 :end 8)
    (is (= 3 (read-element s)))
    (is (= 4 (read-element s)))
    (is (= 5 (read-element s)))
    (is (= 6 (read-element s)))
    (is (= 7 (read-element s)))
    (is (eql :eof (read-element s nil :eof)))
    (signals end-of-file (read-element s)))
  (with-io-stream (s)
    (write-sequence #(t 5 nil "abc" #(3.14 1.41)) s)
    (is-true (read-element s))
    (is (= 5 (read-element s)))
    (is-false (read-element s))
    (is (string= "abc" (read-element s)))
    (is (equalp #(3.14 1.41) (read-element s)))
    (is (eql :eof (read-element s nil :eof)))
    (signals end-of-file (read-element s))))

(test read-sequence/io
  (with-io-stream (s :element-type 'fixnum)
    (write-sequence #(0 1 2 3 4 5 6 7 8 9) s)
    (let ((seq (make-array 5 :element-type 'fixnum)))
      (is (= 2 (read-sequence seq s :end 2)))
      (is (equalp #(0 1) (subseq seq 0 2)))
      (is (= 4 (read-sequence seq s :start 2 :end 4)))
      (is (equalp #(0 1 2 3) (subseq seq 0 4)))
      (is (= 5 (read-sequence seq s)))
      (is (equalp #(4 5 6 7 8) seq))
      (is (= 1 (read-sequence seq s)))
      (is (equalp #(9) (subseq seq 0 1)))
      (is (zerop (read-sequence seq s)))))
  (with-io-stream (s)
    (write-sequence #(t 5 nil "abc" #(3.14 1.41)) s)
    (let ((seq (make-array 5)))
      (is (= 5 (read-sequence seq s)))
      (is (equalp #(t 5 nil "abc" #(3.14 1.41)) seq)))))

(test clear-input/io
  (with-io-stream (s)
    (write-sequence #(0 1 2 3 4 5 6 7 8 9) s)
    (is (= 0 (read-element s)))
    (is (= 1 (read-element s)))
    (is (= 2 (read-element s)))
    (clear-input s)
    (signals end-of-file (read-element s))))

(test write-element/io
  (with-io-stream (s)
    (is (= 1 (write-element 1 s)))
    (is (eql nil (write-element nil s)))
    (is (string= "abc" (write-element "abc" s)))
    (is (equalp '(1 2 3) (write-element '(1 2 3) s)))
    (is (= #c(-0.12d0 0.3d0) (write-element #c(-0.12d0 0.3d0) s)))
    (is (equalp #(1 nil "abc" (1 2 3) #c(-0.12d0 0.3d0))
                (get-elements s))))
  (with-io-stream (s :element-type 'string)
    (is (= 0 (stream-length s)))
    (is (string= "abc" (write-element "abc" s)))
    (is (= 1 (stream-length s)))
    (is (string= "123" (write-element "123" s)))
    (is (= 2 (stream-length s)))
    (is (string= "XYZ" (write-element "XYZ" s)))
    (is (= 3 (stream-length s)))
    (is (equalp #("abc" "123" "XYZ") (get-elements s)))))

(test write-sequence/io
  (with-io-stream (s :element-type 'fixnum)
    (let ((seq (make-array 500 :element-type 'fixnum)))
      (dotimes (i 500)
        (setf (aref seq i) (- (mod (expt i 5) 1000) 500)))
      (is (eq seq (write-sequence seq s :end 5)))
      (is (eq seq (write-sequence seq s :start 5 :end 10)))
      (is (equalp #(-500 -499 -468 -257 -476 -375 276 307 268 -451)
                  (get-elements s)))
      (is (eq seq (write-sequence seq s)))
      (is (equalp seq (get-elements s)))
      (is (eq seq (write-sequence seq s :start 490)))
      (is (equalp #(-500 -49 -268 193 -276 -125 476 -243 468 -1)
                  (get-elements s))))))

(test clear-output/io
  (with-io-stream (s)
    (is (eql t (write-element t s)))
    (is (eql nil (write-element nil s)))
    (is (eql nil (write-element nil s)))
    (is (eql t (write-element t s)))
    (is (eql t (write-element t s)))
    (clear-output s)
    (is (equalp #() (get-elements s)))))
